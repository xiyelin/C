

-----------------------------------------------------------------------------------------------------------------------------------
    
	冒泡排序（bubble sort）算法的运作如下：从前往后一次比较相邻的两个元素，如果第二个比第一个元素小，则交换这两个元素，
	一直到与最后一个元素比较完成，这样最大的元素就放到了最后；这样重复比较（n-1）次即可完成排序。

-----------------------------------------------------------------------------------------------------------------------------------

    快速排序（quicksort）算法（冒泡排序的一种优化）：
    
        1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；
        2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；
        3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；
        4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；
        5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，
           使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正
           好是i+或j-完成的时候，此时令循环结束）。
                                                                                                         
    设置标志位（sign）（冒泡排序的另一种优化方法）每一趟比较完成后，看元素是否进行交换，如果有，则继续下一次循环，如果
    没有则结束循环。“设置标志位”这种方法没有“快速排序算法”效率高。

-----------------------------------------------------------------------------------------------------------------------------------


```c


		/*
		** bubble sort
		*/ 
		void bubble_sort(int *str, int size)
		{
		     int i = 0, j = 0;
		     int tmp = 0;
		      
		     /*
		     ** 进行size-1趟排序；
		     */
		     for (i = 0; i < size - 1; i++)
		     {
		         /*
		         ** 每排序一趟，将最大的元素沉底。下一趟少比较i次；
		         */
		 
		          for (j = 0; j < size - 1 - i; j++)       
		          {
		               if (str[j] > str[j + 1])
		               {
		                    tmp = str[j];
		                    str[j] = str[j + 1];
		                    str[j + 1] = tmp;
		               }
		          }
		 
		     }
		}


```
 
 -----------------------------------------------------------------------------------------------------------------------------------
 
 
 ```c
 
		 
		/*
		** 优化一：设置一个标志位sign的bubble sort；
		*/
		 void bubble_sort(int *str, int size)
		{
		     int i = 0, j = 0;
		     int tmp = 0, sign = 0;
		      
		     for (i = 0; i < size - 1; i++)
		     {
		          /*
		          ** 每趟排序前将sign置为0，如果相邻元素进行了交换则sign>1;
		          ** 否则，sign==0，没有进行交换，排序完成，跳出循环；
		          */
		          sign = 0;
		          for (j = 0; j < size - 1 - i; j++)
		          {
		               if (str[j] > str[j + 1])
		               {
		                    tmp = str[j];
		                    str[j] = str[j + 1];
		                    str[j + 1] = tmp;
		                    sign++;
		               }
		          }
		          if (0 == sign)
		          break;
		     }
		}
 
 
 ```
 
 -----------------------------------------------------------------------------------------------------------------------------------
 
 
 ```c
 
 
		/*
		** 优化二：quick sort；
		*/
		void quicksort(int *str, int left, int right)
		{
		     assert(str);
		      
		     /*
		     **如果左边大于或等于右边，则该数组已经排序完成；
		     */
		     if (left >= right)
		     {
		          return;
		     }
		      
		     int i = left;
		     int j = right;
		     int key = str[left];
		      
		     /*
		     **当i=j时，一趟排序完成，将所有数分为一大一小两组；
		     */
		     while (i < j)
		     {
		          /*
		          **第一次从后向前遍历，遇到第一个比key小的交换两数位置；
		          */
		          while ((i < j) && (key <= str[j]))
		          {
		               j--;
		          }
		          str[i] = str[j];
		           
		          /*
		          **第二次从前向后遍历，遇到第一个比key大的交换两数位置；
		          */
		          while ((i < j) && (key >= str[i]))
		          {
		               i++;
		          }
		          str[j] = str[i];
		     }
		      
		     str[i] = key;
		     /*
		     **递归调用，完成左、右子序列的排序；
		     */
		     quicksort(str, left, i - 1);
		     quicksort(str, i + 1, right);
		}


```


-----------------------------------------------------------------------------------------------------------------------------------


    当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。
    
    快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；


-----------------------------------------------------------------------------------------------------------------------------------


